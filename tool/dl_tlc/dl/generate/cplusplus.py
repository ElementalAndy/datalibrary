''' copyright (c) 2010 Fredrik Kihlander, see LICENSE for more info '''

DEFAULT_STD_TYPES = '''
#if defined(_MSC_VER)

    #ifndef DL_STD_TYPES_DEFINED
    #define DL_STD_TYPES_DEFINED
        typedef signed   __int8  int8_t;
        typedef signed   __int16 int16_t;
        typedef signed   __int32 int32_t;
        typedef signed   __int64 int64_t;
        typedef unsigned __int8  uint8_t;
        typedef unsigned __int16 uint16_t;
        typedef unsigned __int32 uint32_t;
        typedef unsigned __int64 uint64_t;
    #endif // DL_STD_TYPES_DEFINED

#elif defined(__GNUC__)
    #include <stdint.h>
#endif
'''

ARRAY_TEMPLATE = '''
#ifndef DL_ARRAY_CLASS_DEFINED
#define DL_ARRAY_CLASS_DEFINED
template<typename T>
struct TDLArray
{
    T* %(data_name)s;
    %(count_type)s %(count_name)s;

          T& operator[](unsigned int index)        { return %(data_name)s[index]; }
    const T& operator[](unsigned int index) const  { return %(data_name)s[index]; }
};
#endif // DL_ARRAY_CLASS_DEFINED
'''

HEADER_TEMPLATE = '''
/* Autogenerated file for DL-type-library! */

#ifndef %(module)s_H_INCLUDED
#define %(module)s_H_INCLUDED

%(define_pods)s

%(user_code)s

%(array_template)s

%(structs)s

#endif // %(module)s_H_INCLUDED
'''

verbose = False # TODO: not global plox!!!

# TODO: read this config from user!!!
a_config_here = { 'int8'   : 'int8_t',
                  'int16'  : 'int16_t',
                  'int32'  : 'int32_t',
                  'int64'  : 'int64_t',
                  'uint8'  : 'uint8_t',
                  'uint16' : 'uint16_t',
                  'uint32' : 'uint32_t',
                  'uint64' : 'uint64_t',
                  'fp32'   : 'float',
                  'fp64'   : 'double',
                  'string' : 'const char*' }

def to_cpp_name( typename ):
    if typename in a_config_here:
        return a_config_here[typename]
    return typename

def emit_member( member, stream ):
    if verbose:
        print >> stream, '\t// 32bit: size %u, align %u, offset %u' % ( member.size.ptr32, member.align.ptr32, member.offset.ptr32 )
        print >> stream, '\t// 64bit: size %u, align %u, offset %u' % ( member.size.ptr64, member.align.ptr64, member.offset.ptr64 )
        
    if member.comment:
        print >> stream, '\t//', member.comment
    
    import dl.typelibrary as tl
    
    if   isinstance( member, tl.PodMember ):         print >> stream, '\t%s %s;' % ( to_cpp_name( member.type ), member.name )
    elif isinstance( member, tl.ArrayMember ):       print >> stream, '\tTDLArray<%s> %s;' % ( to_cpp_name( member.type ), member.name )
    elif isinstance( member, tl.InlineArrayMember ): print >> stream, '\t%s %s[%u];' % ( to_cpp_name( member.type ), member.name, member.count ) 
    elif isinstance( member, tl.PointerMember ):     print >> stream, '\tconst %s* %s;' % ( to_cpp_name( member.type ), member.name )
    elif isinstance( member, tl.BitfieldMember ):    print >> stream, '\t%s %s : %u;' % ( to_cpp_name( member.type ), member.name, member.bits )
    else:
        assert False, 'missing type (%s)!' % type( member )

def emit_struct( type, stream ):
    #if verbose:
    print >> stream, '// size32 %u, size64 %u, align32 %u, align64 %u' % ( type.size.ptr32, type.size.ptr64, type.align.ptr32, type.align.ptr64 )
    
    if type.comment:
        print >> stream, '//', type.comment
    
    align_str = ' ' if not type.useralign else ' DL_ALIGN( %u ) ' % type.align.ptr32
    print >> stream, 'struct%s%s\n{' % ( align_str, type.name )
    print >> stream, '\tconst static %s TYPE_ID = 0x%08X;\n' % ( to_cpp_name('uint32'), type.typeid )
    
    for m in type.members:
        emit_member( m, stream )  
    
    print >> stream, '};\n'
    
def emit_enum( enum, stream ):
    stream.write( 'enum %s\n{' % enum.name )
    stream.write( ','.join( '\n\t%s = %u' % ( e.name, e.value ) for e in enum.values ) )
    stream.write( '\n};\n\n' )

def generate( typelibrary, config, stream ):
    ''' generates a string containing a cpp-header representing the input typelibrary '''
    
    from StringIO import StringIO
    
    structs = StringIO()
    
    for enum in typelibrary.enums.values():
        emit_enum( enum, structs )
    
    for type_name in typelibrary.type_order:
        emit_struct( typelibrary.types[type_name], structs )
    
    stream.write( HEADER_TEMPLATE % { 'module'         : typelibrary.name.upper(),
                                      'define_pods'    : DEFAULT_STD_TYPES,
                                      'user_code'      : '// USER CODE',
                                      'array_template' : ARRAY_TEMPLATE % { 'data_name'  : 'data',
                                                                            'count_name' : 'count',
                                                                            'count_type' : to_cpp_name('uint32') },
                                      'structs'        : structs.getvalue() } )
