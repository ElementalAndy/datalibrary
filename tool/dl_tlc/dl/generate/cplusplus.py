''' copyright (c) 2010 Fredrik Kihlander, see LICENSE for more info '''

DEFAULT_STD_TYPES = '''
#if defined(_MSC_VER)

    #ifndef DL_STD_TYPES_DEFINED
    #define DL_STD_TYPES_DEFINED
        typedef signed   __int8  int8_t;
        typedef signed   __int16 int16_t;
        typedef signed   __int32 int32_t;
        typedef signed   __int64 int64_t;
        typedef unsigned __int8  uint8_t;
        typedef unsigned __int16 uint16_t;
        typedef unsigned __int32 uint32_t;
        typedef unsigned __int64 uint64_t;
    #endif // DL_STD_TYPES_DEFINED

#elif defined(__GNUC__)
    #include <stdint.h>
#endif
'''

ARRAY_TEMPLATE = '''
#ifndef DL_ARRAY_CLASS_DEFINED
#define DL_ARRAY_CLASS_DEFINED
template<typename T>
struct TDLArray
{
    T* %(data_name)s;
    %(count_type)s %(count_name)s;

          T& operator[](unsigned int index)        { return %(data_name)s[index]; }
    const T& operator[](unsigned int index) const  { return %(data_name)s[index]; }
};
#endif // DL_ARRAY_CLASS_DEFINED
'''

CLASS_TEMPLATE = '''// size32 %(size32)u, size64 %(size64)u, align32 %(align32)u, align64 %(align64)u
struct%(align_str)s%(name)s
{
    const static %(uint32)s TYPE_ID = 0x%(typeid)08X;
    
    %(members)s
};
'''

HEADER_TEMPLATE = '''
/* Autogenerated file for DL-type-library! */

#ifndef %(module)s_H_INCLUDED
#define %(module)s_H_INCLUDED

%(define_pods)s

%(user_code)s

%(array_template)s

%(structs)s

#endif // %(module)s_H_INCLUDED
'''

verbose = False # TODO: not global plox!!!

# TODO: read this config from user!!!
a_config_here = { 'int8'   : 'int8_t',
                  'int16'  : 'int16_t',
                  'int32'  : 'int32_t',
                  'int64'  : 'int64_t',
                  'uint8'  : 'uint8_t',
                  'uint16' : 'uint16_t',
                  'uint32' : 'uint32_t',
                  'uint64' : 'uint64_t',
                  'fp32'   : 'float',
                  'fp64'   : 'double',
                  'string' : 'const char*' }

def to_cpp_name( typename ):
    if typename in a_config_here:
        return a_config_here[typename]
    return typename

def emit_member( member ):
    lines = []        
    if verbose:
        lines.append( '// 32bit: size %u, align %u, offset %u' % ( member.size.ptr32, member.align.ptr32, member.offset.ptr32 ) )
        lines.append( '// 64bit: size %u, align %u, offset %u' % ( member.size.ptr64, member.align.ptr64, member.offset.ptr64 ) )
    
    if member.comment:
        lines.append( '// %s' % member.comment )
        
    import dl.typelibrary as tl
    
    if   isinstance( member, tl.PodMember ):         lines.append( '%s %s;' % ( to_cpp_name( member.type ), member.name ) )
    elif isinstance( member, tl.ArrayMember ):       lines.append( 'TDLArray<%s> %s;' % ( to_cpp_name( member.type ), member.name ) )
    elif isinstance( member, tl.InlineArrayMember ): lines.append( '%s %s[%u];' % ( to_cpp_name( member.type ), member.name, member.count ) ) 
    elif isinstance( member, tl.PointerMember ):     lines.append( 'const %s* %s;' % ( to_cpp_name( member.type ), member.name ) )
    elif isinstance( member, tl.BitfieldMember ):    lines.append( '%s %s : %u;' % ( to_cpp_name( member.type ), member.name, member.bits ) )
    else:
        assert False, 'missing type (%s)!' % type( member )
        
    return lines

def emit_struct( type, stream ):
    #if verbose:
    if type.comment:
        print >> stream, '//', type.comment
        
    member_lines = []
    for m in type.members:
        member_lines.extend( emit_member( m ) )
        
    stream.write( CLASS_TEMPLATE % { 'size32'    : type.size.ptr32,
                             'size64'    : type.size.ptr64,
                             'align32'   : type.align.ptr32,
                             'align64'   : type.align.ptr64,
                             'align_str' : ' ' if not type.useralign else ' DL_ALIGN( %u ) ' % type.align.ptr32,
                             'name'      : type.name,
                             'uint32'    : to_cpp_name('uint32'),
                             'typeid'    : type.typeid,
                             'members'   : '\n    '.join( member_lines ) } )
    
def emit_enum( enum, stream ):
    stream.write( 'enum %s\n{' % enum.name )
    stream.write( ','.join( '\n\t%s = %u' % ( e.name, e.value ) for e in enum.values ) )
    stream.write( '\n};\n\n' )

def generate( typelibrary, config, stream ):
    ''' generates a string containing a cpp-header representing the input typelibrary '''
    
    from StringIO import StringIO
    
    structs = StringIO()
    
    for enum in typelibrary.enums.values():
        emit_enum( enum, structs )
    
    for type_name in typelibrary.type_order:
        emit_struct( typelibrary.types[type_name], structs )
    
    stream.write( HEADER_TEMPLATE % { 'module'         : typelibrary.name.upper(),
                                      'define_pods'    : DEFAULT_STD_TYPES,
                                      'user_code'      : '// USER CODE',
                                      'array_template' : ARRAY_TEMPLATE % { 'data_name'  : 'data',
                                                                            'count_name' : 'count',
                                                                            'count_type' : to_cpp_name('uint32') },
                                      'structs'        : structs.getvalue() } )
