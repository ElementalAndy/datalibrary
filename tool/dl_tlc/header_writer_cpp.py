''' copyright (c) 2010 Fredrik Kihlander, see LICENSE for more info '''

HEADER_TEMPLATE_C = '''#ifndef %(module)s_H_INCLUDED
#define %(module)s_H_INCLUDED

/*
	Autogenerated file for DL-type-library!
*/

%(header)s

%(user_code)s

'''

HEADER_TEMPLATE_CPP = '''#ifndef %(module)s_H_INCLUDED
#define %(module)s_H_INCLUDED

/*
	Autogenerated file for DL-type-library!
*/

%(header)s

%(user_code)s

#ifndef DL_ARRAY_CLASS_DEFINED
#define DL_ARRAY_CLASS_DEFINED

template<typename T>
struct TDLArray
{
	T* %(array_member_data)s;
	%%(uint32)s %(array_member_count)s;

	// TODO: Fix asserts so that user might specify them as they se fit!
	T& operator[](unsigned int _Index)
	{
		// M_ASSERT(_Index < %(array_member_count)s, "Index out of range! Array size %%%%u, requested index %%%%u", %(array_member_count)s, _Index);
		return %(array_member_data)s[_Index];
	}

	const T& operator[](unsigned int _Index) const 
	{
		// M_ASSERT(_Index < %(array_member_count)s, "Index out of range! Array size %%%%u, requested index %%%%u", %(array_member_count)s, _Index);
		return %(array_member_data)s[_Index];
	}
};

#endif // DL_ARRAY_CLASS_DEFINED 

'''

PODS = [ 'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32', 'uint64', 'fp32', 'fp64', 'string', 'bitfield' ]
	
def temp_hash_func(str):
	hash = 5381
	for char in str:
		hash = (hash * 33) + ord(char)
	return (hash - 5381) & 0xFFFFFFFF;
	
class HeaderWriterCPP:
	def __write_member(self, str, attribs):
		if self.verbose:
			print >> self.stream, '\t// size %(size32)u, alignment %(align32)u, offset %(offset32)u' % attribs
			
		if 'comment' in attribs:
			print >> self.stream, (str + '\t// %(comment)s') % attribs
		else:
			print >> self.stream, str % attribs
			
	def write_header(self, data):
		if self.pure_c:
			print >> self.stream, HEADER_TEMPLATE_C % { 'module'    : data['module_name'].upper(), 
													    'user_code' : data.get('module_cpp_header', ''),
													    'header'    : self.config['header'] }
		else:
			print >> self.stream, HEADER_TEMPLATE_CPP % { 'module'    : data['module_name'].upper(), 
													      'user_code' : data.get('module_cpp_header', ''),
													      'header'    : self.config['header'],
													      'array_member_data'  : self.config['array_names']['data'],
													      'array_member_count' : self.config['array_names']['count'] }
		
	def finalize(self, data):
		print >> self.stream, '#endif // %s_H_INCLUDED' % data['module_name'].upper()
		
		# Replace stuff here!
		out_text = self.stream.getvalue()		
		self.out.write( out_text % self.config['pod_names'] )
		
	def write_enums(self, data):
		if data.has_key('module_enums'):
			for enum in data['module_enums'].items():
				enum_name = enum[0]
				enum_base = enum_name.upper()
				enum_values = enum[1]
				
				self.stream.write('enum ' + enum_name + '\n{')
				for i in range(0, len(enum_values)):
					value = enum_values[i]
					self.stream.write('\n\t%s_%s = %d' % (enum_base, value[0].upper(), value[1]))
					
					if i != len(enum_values) - 1:
						self.stream.write(',')
				print >> self.stream, '\n};\n'
	
	def create_header_order(self, outlist, type, data, enums):
		if type in outlist or type in PODS or type in enums:
			return
		
		member_types = []
		for m in data[type]['members']:
			m_type = m.get('subtype', m['type'])
			if m_type not in member_types and m_type != type:
				member_types.append(m_type)
		
		for m in member_types:
			self.create_header_order(outlist, m, data, enums)
			
		outlist.append(type)
	
	def write_structs(self, data):
		write_order = []
		
		mod_types  = data['module_types']
		enum_types = data.get('module_enums', {}).keys()
		
		for struct in mod_types.items():
			self.create_header_order(write_order, struct[0], mod_types, enum_types)
		
		for type_name in write_order:
			struct_name       = type_name
			struct_attrib     = mod_types[type_name]
			struct_orig_align = struct_attrib['original_align']
			
			if 'cpp-alias' in struct_attrib: continue # we have an alias so we force the user to provide the type.
			
			print >> self.stream, '// size ', struct_attrib['size32']
			
			if 'comment' in struct_attrib: print >> self.stream, '//', struct_attrib['comment']
			
			if struct_orig_align == 0 or struct_attrib['align'] > struct_orig_align:
				print >> self.stream, 'struct %s\n{' % struct_name
			else:
				print >> self.stream, 'struct DL_ALIGN( %u ) %s\n{' % ( struct_attrib['align'], struct_name )
			
			print >> self.stream, '\tconst static %%(uint32)s TYPE_ID = 0x%08X;\n' % temp_hash_func(struct_name)
			
			for member in struct_attrib['members']:
				type = member['type']
				format_str = ''
				if 'cpp-alias' in member: format_str = '\t%(cpp-alias)s %(name)s;'
				elif type == 'bitfield':  format_str = '\t%%(%(subtype)s)s %(name)s : %(bits)u;'
				elif type == 'string':    format_str = '\tconst char* %(name)s;'
				elif type == 'pointer':   format_str = '\tconst %(subtype)s* %(name)s;'
				elif type in PODS:        format_str = '\t%%(%(type)s)s %(name)s;'
				elif type in enum_types:  format_str = '\t%(type)s %(name)s;'
				elif type == 'inline-array':
					subtype = member['subtype']
					if subtype == 'string': format_str = '\tchar* %(name)s[%(count)u];'
					elif subtype in PODS:   format_str = '\t%%(%(subtype)s)s %(name)s[%(count)u];'
					else:                   format_str = '\t%(subtype)s %(name)s[%(count)u];'
				elif type == 'array':
					subtype = member['subtype']
					if self.pure_c:
						if subtype == 'string': format_str = '''	struct
	{
		const char** ''' + self.config['array_names']['data'] + ''';
		%%(uint32)s ''' + self.config['array_names']['count'] + ''';
	} %(name)s;'''
						elif subtype in PODS:   format_str =  '''	struct
	{
		%%(%(subtype)s)s* ''' + self.config['array_names']['data'] + ''';
		%%(uint32)s ''' + self.config['array_names']['count'] + ''';
	} %(name)s;'''
						else:                   format_str = '''	struct
	{
		%(subtype)s* ''' + self.config['array_names']['data'] + ''';
		%%(uint32)s ''' + self.config['array_names']['count'] + ''';
	} %(name)s;'''
						
					else:
						if subtype == 'string': format_str = '\tTDLArray<char*> %(name)s;'
						elif subtype in PODS:   format_str = '\tTDLArray<%%(%(subtype)s)s> %(name)s;'
						else:                   format_str = '\tTDLArray<%(subtype)s> %(name)s;'
				elif 'cpp-alias' in mod_types[type]:
					format_str = '\t%s %(name)s;' % mod_types[type]['cpp-alias']
				else:
					format_str = '\t%(type)s %(name)s;'
				
				assert format_str != ''
				self.__write_member( format_str, member )
			
			print >> self.stream, '};\n'
		
	def __init__(self, out, config, pure_c):
		from StringIO import StringIO
		self.stream  = StringIO()
		self.out     = out
		self.verbose = False
		self.pure_c  = pure_c
		self.config  = config
